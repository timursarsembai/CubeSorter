<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/cubesorter/SorterActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/cubesorter/SorterActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.cubesorter&#10;&#10;import android.app.Activity&#10;import android.app.AlertDialog&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.view.ContextThemeWrapper&#10;import android.view.LayoutInflater&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import android.graphics.Color&#10;import java.util.Locale&#10;&#10;class SorterActivity : Activity() {&#10;&#10;    private lateinit var textLevel: TextView&#10;    private lateinit var textTimer: TextView&#10;    private lateinit var textMoves: TextView&#10;    private lateinit var sorterGameView: SorterGameView&#10;&#10;    private var startTime: Long = 0&#10;    private var isTimerRunning = false&#10;&#10;    // Диалог завершения уровня&#10;    private var levelDialog: AlertDialog? = null&#10;&#10;    // Хранение прогресса&#10;    private val prefs by lazy { getSharedPreferences(&quot;progress&quot;, MODE_PRIVATE) }&#10;&#10;    // Админ режим&#10;    private var isAdminMode = false&#10;    private var isLevelPressing = false&#10;    private val longPressThresholdMs = 10_000L&#10;    private val levelPressHandler = Handler(Looper.getMainLooper())&#10;    private var levelLongPressRunnable: Runnable? = null&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val timerRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isTimerRunning) {&#10;                updateTimer()&#10;                handler.postDelayed(this, 100)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_sorter)&#10;&#10;        initializeViews()&#10;        setupGameCallbacks()&#10;        setupAdminGesture()&#10;        startNewGame()&#10;        restoreProgressIfAny()&#10;    }&#10;&#10;    private fun initializeViews() {&#10;        textLevel = findViewById(R.id.textLevel)&#10;        textTimer = findViewById(R.id.textTimer)&#10;        textMoves = findViewById(R.id.textMoves)&#10;        sorterGameView = findViewById(R.id.sorterGameView)&#10;    }&#10;&#10;    private fun setupGameCallbacks() {&#10;        sorterGameView.onMovesChanged = { moves -&gt;&#10;            textMoves.text = moves.toString()&#10;            if (moves == 1 &amp;&amp; !isTimerRunning) startTimer()&#10;        }&#10;&#10;        sorterGameView.onRoundChanged = { round, _ -&gt;&#10;            textLevel.text = round.toString()&#10;            resetTimer()&#10;            saveLevel(round)&#10;        }&#10;&#10;        sorterGameView.onRoundCompleted = { round, moves -&gt;&#10;            pauseTimer()&#10;            showLevelCompletedDialog(round, moves)&#10;        }&#10;&#10;        sorterGameView.onAllCompleted = {&#10;            // Все уровни завершены&#10;            resetTimer()&#10;            saveLevel(SorterGameView.MAX_LEVEL) // сохраняем финальный уровень&#10;            startCongratulations()&#10;        }&#10;    }&#10;&#10;    private fun showLevelCompletedDialog(round: Int, moves: Int) {&#10;        levelDialog?.dismiss()&#10;        val inflaterContext = ContextThemeWrapper(this, R.style.LevelCompleteDialogTheme)&#10;        val view = LayoutInflater.from(inflaterContext).inflate(R.layout.dialog_level_completed, null, false)&#10;        val title = view.findViewById&lt;TextView&gt;(R.id.textTitle)&#10;        val message = view.findViewById&lt;TextView&gt;(R.id.textMessage)&#10;        val statTime = view.findViewById&lt;TextView&gt;(R.id.textStatTime)&#10;        val statMoves = view.findViewById&lt;TextView&gt;(R.id.textStatMoves)&#10;        val btnRepeat = view.findViewById&lt;ImageButton&gt;(R.id.buttonRepeat)&#10;        val btnNext = view.findViewById&lt;ImageButton&gt;(R.id.buttonNext)&#10;&#10;        title.text = getString(R.string.level_completed_congrats)&#10;        val timeStr = textTimer.text.toString()&#10;        message.text = getString(R.string.level_completed_message)&#10;        statTime.text = timeStr&#10;        statMoves.text = moves.toString()&#10;&#10;        val dialog = AlertDialog.Builder(inflaterContext)&#10;            .setView(view)&#10;            .setCancelable(false)&#10;            .create()&#10;        levelDialog = dialog&#10;&#10;        btnRepeat.setOnClickListener {&#10;            dialog.dismiss()&#10;            sorterGameView.jumpToLevel(sorterGameView.currentRound)&#10;        }&#10;&#10;        btnNext.setOnClickListener {&#10;            dialog.dismiss()&#10;            sorterGameView.nextRound()&#10;        }&#10;&#10;        dialog.show()&#10;    }&#10;&#10;    private fun restoreProgressIfAny() {&#10;        val saved = prefs.getInt(&quot;current_level&quot;, 1)&#10;        if (saved in 2..SorterGameView.MAX_LEVEL) {&#10;            sorterGameView.jumpToLevel(saved)&#10;        }&#10;    }&#10;&#10;    private fun saveLevel(lv: Int) {&#10;        prefs.edit().putInt(&quot;current_level&quot;, lv.coerceIn(1, SorterGameView.MAX_LEVEL)).apply()&#10;    }&#10;&#10;    private fun setupAdminGesture() {&#10;        // Клик по номеру уровня в админ-режиме -&gt; переход по номеру&#10;        textLevel.setOnClickListener {&#10;            if (isAdminMode) showLevelJumpDialog()&#10;        }&#10;&#10;        textLevel.setOnTouchListener { _, event -&gt;&#10;            if (isAdminMode) return@setOnTouchListener false&#10;            when (event.actionMasked) {&#10;                android.view.MotionEvent.ACTION_DOWN -&gt; {&#10;                    isLevelPressing = true&#10;                    levelLongPressRunnable = Runnable {&#10;                        if (isLevelPressing &amp;&amp; !isAdminMode) {&#10;                            showAdminCodeDialog()&#10;                        }&#10;                    }&#10;                    levelPressHandler.postDelayed(levelLongPressRunnable!!, longPressThresholdMs)&#10;                }&#10;                android.view.MotionEvent.ACTION_UP, android.view.MotionEvent.ACTION_CANCEL -&gt; {&#10;                    isLevelPressing = false&#10;                    levelLongPressRunnable?.let { levelPressHandler.removeCallbacks(it) }&#10;                }&#10;            }&#10;            true&#10;        }&#10;    }&#10;&#10;    private fun showAdminCodeDialog() {&#10;        val input = EditText(this).apply {&#10;            inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD&#10;            hint = &quot;Enter admin code&quot;&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Administrator Access&quot;)&#10;            .setMessage(&quot;Hold 10s detected. Enter code:&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;OK&quot;) { d, _ -&gt;&#10;                val code = input.text.toString().trim()&#10;                if (code == &quot;ROOT&quot;) {&#10;                    isAdminMode = true&#10;                    Toast.makeText(this, &quot;Admin mode enabled&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(this, &quot;Wrong code&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                d.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { d, _ -&gt; d.dismiss() }&#10;            .setCancelable(false)&#10;            .show()&#10;    }&#10;&#10;    private fun showLevelJumpDialog() {&#10;        val input = EditText(this).apply {&#10;            inputType = InputType.TYPE_CLASS_NUMBER&#10;            filters = arrayOf(InputFilter.LengthFilter(2))&#10;            hint = &quot;Level (1-40)&quot;&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Jump to Level&quot;)&#10;            .setMessage(&quot;Enter level number 1..40&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Go&quot;) { d, _ -&gt;&#10;                val text = input.text.toString().trim()&#10;                val num = text.toIntOrNull()&#10;                if (num != null &amp;&amp; num in 1..SorterGameView.MAX_LEVEL) {&#10;                    sorterGameView.jumpToLevel(num)&#10;                    Toast.makeText(this, &quot;Jumped to level $num&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(this, &quot;Invalid level&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                d.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { d, _ -&gt; d.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun startCongratulations() {&#10;        startActivity(Intent(this, CongratulationsActivity::class.java))&#10;    }&#10;&#10;    private fun startNewGame() {&#10;        textLevel.text = &quot;1&quot;&#10;        textMoves.text = &quot;0&quot;&#10;        textTimer.text = getString(R.string.time_zero_tenth)&#10;        resetTimer()&#10;    }&#10;&#10;    private fun startTimer() {&#10;        startTime = System.currentTimeMillis()&#10;        isTimerRunning = true&#10;        handler.post(timerRunnable)&#10;    }&#10;&#10;    private fun pauseTimer() {&#10;        isTimerRunning = false&#10;        handler.removeCallbacks(timerRunnable)&#10;    }&#10;&#10;    private fun resetTimer() {&#10;        isTimerRunning = false&#10;        handler.removeCallbacks(timerRunnable)&#10;        startTime = 0&#10;        textTimer.text = getString(R.string.time_zero_tenth)&#10;    }&#10;&#10;    private fun updateTimer() {&#10;        val currentTime = System.currentTimeMillis()&#10;        val elapsedTime = currentTime - startTime&#10;        val minutes = (elapsedTime / 60000).toInt()&#10;        val seconds = ((elapsedTime % 60000) / 1000).toInt()&#10;        val tenths = ((elapsedTime % 1000) / 100).toInt()&#10;&#10;        textTimer.text = String.format(Locale.getDefault(), &quot;%02d:%02d.%d&quot;, minutes, seconds, tenths)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        resetTimer()&#10;        levelDialog?.dismiss()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.timursarsembayev.cubesorter&#10;&#10;import android.app.Activity&#10;import android.app.AlertDialog&#10;import android.content.Intent&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.text.InputFilter&#10;import android.text.InputType&#10;import android.view.ContextThemeWrapper&#10;import android.view.LayoutInflater&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import java.util.Locale&#10;&#10;class SorterActivity : Activity() {&#10;&#10;    private lateinit var textLevel: TextView&#10;    private lateinit var textTimer: TextView&#10;    private lateinit var textMoves: TextView&#10;    private lateinit var sorterGameView: SorterGameView&#10;&#10;    private var startTime: Long = 0&#10;    private var isTimerRunning = false&#10;&#10;    // Диалог завершения уровня&#10;    private var levelDialog: AlertDialog? = null&#10;&#10;    // Хранение прогресса&#10;    private val prefs by lazy { getSharedPreferences(&quot;progress&quot;, MODE_PRIVATE) }&#10;&#10;    // Админ режим&#10;    private var isAdminMode = false&#10;    private var isLevelPressing = false&#10;    private val longPressThresholdMs = 10_000L&#10;    private val levelPressHandler = Handler(Looper.getMainLooper())&#10;    private var levelLongPressRunnable: Runnable? = null&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val timerRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isTimerRunning) {&#10;                updateTimer()&#10;                handler.postDelayed(this, 100)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_sorter)&#10;&#10;        initializeViews()&#10;        setupGameCallbacks()&#10;        setupAdminGesture()&#10;        startNewGame()&#10;        restoreProgressIfAny()&#10;    }&#10;&#10;    private fun initializeViews() {&#10;        textLevel = findViewById(R.id.textLevel)&#10;        textTimer = findViewById(R.id.textTimer)&#10;        textMoves = findViewById(R.id.textMoves)&#10;        sorterGameView = findViewById(R.id.sorterGameView)&#10;    }&#10;&#10;    // ---- Records helpers ----&#10;    private fun bestTimeKey(level: Int) = &quot;best_time_$level&quot; // Long (ms)&#10;    private fun bestMovesKey(level: Int) = &quot;best_moves_$level&quot; // Int&#10;    private fun getBestTime(level: Int): Long = prefs.getLong(bestTimeKey(level), Long.MAX_VALUE)&#10;    private fun getBestMoves(level: Int): Int = prefs.getInt(bestMovesKey(level), Int.MAX_VALUE)&#10;    private fun saveBestTime(level: Int, v: Long) { prefs.edit().putLong(bestTimeKey(level), v).apply() }&#10;    private fun saveBestMoves(level: Int, v: Int) { prefs.edit().putInt(bestMovesKey(level), v).apply() }&#10;    private fun formatElapsed(ms: Long): String {&#10;        if (ms == Long.MAX_VALUE) return &quot;--:--.-&quot;&#10;        val m = (ms / 60000).toInt(); val s = ((ms % 60000)/1000).toInt(); val t = ((ms % 1000)/100).toInt()&#10;        return String.format(Locale.getDefault(), &quot;%02d:%02d.%d&quot;, m, s, t)&#10;    }&#10;&#10;    private fun setupGameCallbacks() {&#10;        sorterGameView.onMovesChanged = { moves -&gt;&#10;            textMoves.text = moves.toString()&#10;            if (moves == 1 &amp;&amp; !isTimerRunning) startTimer()&#10;        }&#10;&#10;        sorterGameView.onRoundChanged = { round, _ -&gt;&#10;            textLevel.text = round.toString()&#10;            resetTimer()&#10;            saveLevel(round)&#10;        }&#10;&#10;        sorterGameView.onRoundCompleted = { round, moves -&gt;&#10;            val elapsedMillis = if (startTime &gt; 0) System.currentTimeMillis() - startTime else 0L&#10;            pauseTimer()&#10;            showLevelCompletedDialog(round, moves, elapsedMillis)&#10;        }&#10;&#10;        sorterGameView.onAllCompleted = {&#10;            // Все уровни завершены&#10;            resetTimer()&#10;            saveLevel(SorterGameView.MAX_LEVEL) // сохраняем финальный уровень&#10;            startCongratulations()&#10;        }&#10;    }&#10;&#10;    // Заменяем старую версию: теперь с elapsedMillis и рекордами&#10;    private fun showLevelCompletedDialog(round: Int, moves: Int, elapsedMillis: Long) {&#10;        levelDialog?.dismiss()&#10;        val ctx = ContextThemeWrapper(this, R.style.LevelCompleteDialogTheme)&#10;        val view = LayoutInflater.from(ctx).inflate(R.layout.dialog_level_completed, null, false)&#10;&#10;        val message = view.findViewById&lt;TextView&gt;(R.id.textMessage)&#10;        val statTime = view.findViewById&lt;TextView&gt;(R.id.textStatTime)&#10;        val statMoves = view.findViewById&lt;TextView&gt;(R.id.textStatMoves)&#10;        val bestTimeView = view.findViewById&lt;TextView&gt;(R.id.textBestTime)&#10;        val bestMovesView = view.findViewById&lt;TextView&gt;(R.id.textBestMoves)&#10;        val btnRepeat = view.findViewById&lt;ImageButton&gt;(R.id.buttonRepeat)&#10;        val btnNext = view.findViewById&lt;ImageButton&gt;(R.id.buttonNext)&#10;&#10;        val prevBestTime = getBestTime(round)&#10;        val prevBestMoves = getBestMoves(round)&#10;        var newTimeRecord = false&#10;        var newMovesRecord = false&#10;        if (elapsedMillis &lt; prevBestTime) { saveBestTime(round, elapsedMillis); newTimeRecord = true }&#10;        if (moves &lt; prevBestMoves) { saveBestMoves(round, moves); newMovesRecord = true }&#10;        val currentBestTime = getBestTime(round)&#10;        val currentBestMoves = getBestMoves(round)&#10;&#10;        // Сообщение&#10;        message.text = when {&#10;            newTimeRecord &amp;&amp; newMovesRecord -&gt; getString(R.string.record_both_congrats)&#10;            newTimeRecord -&gt; getString(R.string.record_time_congrats)&#10;            newMovesRecord -&gt; getString(R.string.record_moves_congrats)&#10;            else -&gt; getString(R.string.level_completed_message)&#10;        }&#10;&#10;        // Текущие значения&#10;        statTime.text = formatElapsed(elapsedMillis)&#10;        statMoves.text = moves.toString()&#10;&#10;        // Best значения&#10;        if (currentBestTime != Long.MAX_VALUE) {&#10;            bestTimeView.text = &quot;Best: ${formatElapsed(currentBestTime)}&quot;&#10;            bestTimeView.visibility = android.view.View.VISIBLE&#10;            if (newTimeRecord) bestTimeView.setTextColor(Color.parseColor(&quot;#2E7D32&quot;)) else bestTimeView.setTextColor(Color.parseColor(&quot;#1976D2&quot;))&#10;        } else bestTimeView.visibility = android.view.View.GONE&#10;&#10;        if (currentBestMoves != Int.MAX_VALUE) {&#10;            bestMovesView.text = &quot;Best: $currentBestMoves&quot;&#10;            bestMovesView.visibility = android.view.View.VISIBLE&#10;            if (newMovesRecord) bestMovesView.setTextColor(Color.parseColor(&quot;#2E7D32&quot;)) else bestMovesView.setTextColor(Color.parseColor(&quot;#1976D2&quot;))&#10;        } else bestMovesView.visibility = android.view.View.GONE&#10;&#10;        val dialog = AlertDialog.Builder(ctx)&#10;            .setView(view)&#10;            .setCancelable(false)&#10;            .create()&#10;        levelDialog = dialog&#10;&#10;        btnRepeat.setOnClickListener {&#10;            dialog.dismiss(); sorterGameView.jumpToLevel(sorterGameView.currentRound)&#10;        }&#10;        btnNext.setOnClickListener {&#10;            dialog.dismiss(); sorterGameView.nextRound()&#10;        }&#10;        dialog.show()&#10;    }&#10;&#10;    private fun restoreProgressIfAny() {&#10;        val saved = prefs.getInt(&quot;current_level&quot;, 1)&#10;        if (saved in 2..SorterGameView.MAX_LEVEL) {&#10;            sorterGameView.jumpToLevel(saved)&#10;        }&#10;    }&#10;&#10;    private fun saveLevel(lv: Int) {&#10;        prefs.edit().putInt(&quot;current_level&quot;, lv.coerceIn(1, SorterGameView.MAX_LEVEL)).apply()&#10;    }&#10;&#10;    private fun setupAdminGesture() {&#10;        // Клик по номеру уровня в админ-режиме -&gt; переход по номеру&#10;        textLevel.setOnClickListener {&#10;            if (isAdminMode) showLevelJumpDialog()&#10;        }&#10;&#10;        textLevel.setOnTouchListener { _, event -&gt;&#10;            if (isAdminMode) return@setOnTouchListener false&#10;            when (event.actionMasked) {&#10;                android.view.MotionEvent.ACTION_DOWN -&gt; {&#10;                    isLevelPressing = true&#10;                    levelLongPressRunnable = Runnable {&#10;                        if (isLevelPressing &amp;&amp; !isAdminMode) {&#10;                            showAdminCodeDialog()&#10;                        }&#10;                    }&#10;                    levelPressHandler.postDelayed(levelLongPressRunnable!!, longPressThresholdMs)&#10;                }&#10;                android.view.MotionEvent.ACTION_UP, android.view.MotionEvent.ACTION_CANCEL -&gt; {&#10;                    isLevelPressing = false&#10;                    levelLongPressRunnable?.let { levelPressHandler.removeCallbacks(it) }&#10;                }&#10;            }&#10;            true&#10;        }&#10;    }&#10;&#10;    private fun showAdminCodeDialog() {&#10;        val input = EditText(this).apply {&#10;            inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD&#10;            hint = &quot;Enter admin code&quot;&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Administrator Access&quot;)&#10;            .setMessage(&quot;Hold 10s detected. Enter code:&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;OK&quot;) { d, _ -&gt;&#10;                val code = input.text.toString().trim()&#10;                if (code == &quot;ROOT&quot;) {&#10;                    isAdminMode = true&#10;                    Toast.makeText(this, &quot;Admin mode enabled&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(this, &quot;Wrong code&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                d.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { d, _ -&gt; d.dismiss() }&#10;            .setCancelable(false)&#10;            .show()&#10;    }&#10;&#10;    private fun showLevelJumpDialog() {&#10;        val input = EditText(this).apply {&#10;            inputType = InputType.TYPE_CLASS_NUMBER&#10;            filters = arrayOf(InputFilter.LengthFilter(2))&#10;            hint = &quot;Level (1-40)&quot;&#10;        }&#10;        AlertDialog.Builder(this)&#10;            .setTitle(&quot;Jump to Level&quot;)&#10;            .setMessage(&quot;Enter level number 1..40&quot;)&#10;            .setView(input)&#10;            .setPositiveButton(&quot;Go&quot;) { d, _ -&gt;&#10;                val text = input.text.toString().trim()&#10;                val num = text.toIntOrNull()&#10;                if (num != null &amp;&amp; num in 1..SorterGameView.MAX_LEVEL) {&#10;                    sorterGameView.jumpToLevel(num)&#10;                    Toast.makeText(this, &quot;Jumped to level $num&quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Toast.makeText(this, &quot;Invalid level&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;                d.dismiss()&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { d, _ -&gt; d.dismiss() }&#10;            .show()&#10;    }&#10;&#10;    private fun startCongratulations() {&#10;        startActivity(Intent(this, CongratulationsActivity::class.java))&#10;    }&#10;&#10;    private fun startNewGame() {&#10;        textLevel.text = &quot;1&quot;&#10;        textMoves.text = &quot;0&quot;&#10;        textTimer.text = getString(R.string.time_zero_tenth)&#10;        resetTimer()&#10;    }&#10;&#10;    private fun startTimer() {&#10;        startTime = System.currentTimeMillis()&#10;        isTimerRunning = true&#10;        handler.post(timerRunnable)&#10;    }&#10;&#10;    private fun pauseTimer() {&#10;        isTimerRunning = false&#10;        handler.removeCallbacks(timerRunnable)&#10;    }&#10;&#10;    private fun resetTimer() {&#10;        isTimerRunning = false&#10;        handler.removeCallbacks(timerRunnable)&#10;        startTime = 0&#10;        textTimer.text = getString(R.string.time_zero_tenth)&#10;    }&#10;&#10;    private fun updateTimer() {&#10;        val currentTime = System.currentTimeMillis()&#10;        val elapsedTime = currentTime - startTime&#10;        val minutes = (elapsedTime / 60000).toInt()&#10;        val seconds = ((elapsedTime % 60000) / 1000).toInt()&#10;        val tenths = ((elapsedTime % 1000) / 100).toInt()&#10;&#10;        textTimer.text = String.format(Locale.getDefault(), &quot;%02d:%02d.%d&quot;, minutes, seconds, tenths)&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        resetTimer()&#10;        levelDialog?.dismiss()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>