<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/cubesorter/SorterGameView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/cubesorter/SorterGameView.kt" />
              <option name="originalContent" value="package com.timursarsembayev.cubesorter&#10;&#10;import android.content.Context&#10;import android.graphics.*&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.SystemClock&#10;import android.util.AttributeSet&#10;import android.view.HapticFeedbackConstants&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import kotlin.math.floor&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;enum class SortType {&#10;    NUMBERS,   // Сортировка чисел 0-9&#10;    COLORS,    // Сортировка цветов&#10;    EMOJIS     // Сортировка смайликов&#10;}&#10;&#10;class SorterGameView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;    companion object { const val MAX_LEVEL = 40 }&#10;&#10;    var onMovesChanged: ((moves: Int) -&gt; Unit)? = null&#10;    var onRoundChanged: ((round: Int, targets: IntArray) -&gt; Unit)? = null&#10;    var onRoundCompleted: ((round: Int, moves: Int) -&gt; Unit)? = null&#10;    // Новый колбэк при завершении всех уровней&#10;    var onAllCompleted: (() -&gt; Unit)? = null&#10;&#10;    private var cols = 4&#10;    private var rows = 7&#10;&#10;    private var cellSize = 0f&#10;    private var gridLeft = 0f&#10;    private var gridTop = 0f&#10;    private var labelArea = 0f&#10;&#10;    private var stacks: MutableList&lt;MutableList&lt;Int&gt;&gt; = MutableList(cols) { mutableListOf() }&#10;&#10;    private var moves = 0&#10;    private var round = 1&#10;    private var targets: IntArray = IntArray(maxOf(1, cols - 1)) { it }&#10;    // Свойство для получения текущего уровня (используется в активности)&#10;    val currentRound: Int get() = round&#10;&#10;    // Текущий тип сортировки&#10;    private var currentSortType: SortType = SortType.NUMBERS&#10;&#10;    private var dragging = false&#10;    private var dragFromCol = -1&#10;    private var dragDigit = -1&#10;    private var dragX = 0f&#10;    private var dragY = 0f&#10;&#10;    private var hoverCol: Int = -1&#10;    private var hoverRow: Int = -1&#10;    private var hoverValid: Boolean = false&#10;&#10;    private var rejectCol: Int = -1&#10;    private var rejectAnimStart: Long = 0L&#10;    private val rejectAnimDuration = 250L&#10;&#10;    private var acceptAnimActive: Boolean = false&#10;    private var acceptAnimStart: Long = 0L&#10;    private val acceptAnimDuration = 350L&#10;&#10;    private var tone: ToneGenerator? = null&#10;&#10;    private val overlayPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val gridPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        style = Paint.Style.STROKE&#10;        color = Color.parseColor(&quot;#22000000&quot;)&#10;        strokeWidth = 2f * resources.displayMetrics.density&#10;    }&#10;    private val cellBgPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        style = Paint.Style.FILL&#10;        color = Color.parseColor(&quot;#10FFFFFF&quot;)&#10;    }&#10;    private val blockPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val shadowPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        maskFilter = BlurMaskFilter(6f * resources.displayMetrics.density, BlurMaskFilter.Blur.NORMAL)&#10;    }&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        textAlign = Paint.Align.CENTER&#10;        typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;    }&#10;    private val labelPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        textAlign = Paint.Align.CENTER&#10;        typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;        color = Color.parseColor(&quot;#263238&quot;)&#10;    }&#10;&#10;    // Цвета для чисел&#10;    private val digitColors = intArrayOf(&#10;        Color.parseColor(&quot;#FF7043&quot;), // 0 - оранжевый&#10;        Color.parseColor(&quot;#42A5F5&quot;), // 1 - голубой&#10;        Color.parseColor(&quot;#66BB6A&quot;), // 2 - зеленый&#10;        Color.parseColor(&quot;#FFA726&quot;), // 3 - желтый&#10;        Color.parseColor(&quot;#AB47BC&quot;), // 4 - фиолетовый&#10;        Color.parseColor(&quot;#26C6DA&quot;), // 5 - бирюзовый&#10;        Color.parseColor(&quot;#EC407A&quot;), // 6 - розовый&#10;        Color.parseColor(&quot;#7E57C2&quot;), // 7 - сиреневый&#10;        Color.parseColor(&quot;#8D6E63&quot;), // 8 - коричневый&#10;        Color.parseColor(&quot;#FFCA28&quot;)  // 9 - золотой&#10;    )&#10;&#10;    // Цвета для сортировки по цветам&#10;    private val sortColors = intArrayOf(&#10;        Color.parseColor(&quot;#F44336&quot;), // 0 - красный&#10;        Color.parseColor(&quot;#FF9800&quot;), // 1 - оранжевый&#10;        Color.parseColor(&quot;#FFEB3B&quot;), // 2 - желтый&#10;        Color.parseColor(&quot;#4CAF50&quot;), // 3 - зеленый&#10;        Color.parseColor(&quot;#2196F3&quot;), // 4 - синий&#10;        Color.parseColor(&quot;#9C27B0&quot;), // 5 - фиолетовый&#10;        Color.parseColor(&quot;#E91E63&quot;), // 6 - розовый&#10;        Color.parseColor(&quot;#795548&quot;), // 7 - коричневый&#10;        Color.parseColor(&quot;#607D8B&quot;), // 8 - серый&#10;        Color.parseColor(&quot;#000000&quot;)  // 9 - черный&#10;    )&#10;&#10;    // Смайлики для сортировки&#10;    private val emojiList = arrayOf(&#10;        &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;&#10;    )&#10;&#10;    init { isClickable = true; resetAll() }&#10;&#10;    fun resetAll() { moves = 0; round = 1; startRound(); notifyMoves() }&#10;    fun nextRound() {&#10;        // Если текущий раунд меньше максимального – идем дальше, иначе уведомляем о полном завершении&#10;        if (round &lt; MAX_LEVEL) {&#10;            round += 1&#10;            startRound()&#10;        } else {&#10;            onAllCompleted?.invoke()&#10;        }&#10;    }&#10;&#10;    // Определяем тип сортировки для текущего раунда&#10;    private fun getSortTypeForRound(round: Int): SortType {&#10;        return when ((round - 1) % 3) {&#10;            0 -&gt; SortType.NUMBERS&#10;            1 -&gt; SortType.COLORS&#10;            2 -&gt; SortType.EMOJIS&#10;            else -&gt; SortType.NUMBERS&#10;        }&#10;    }&#10;&#10;    // Переход на указанный уровень (для режима администратора)&#10;    fun jumpToLevel(level: Int) {&#10;        val target = level.coerceIn(1, MAX_LEVEL)&#10;        round = target&#10;        startRound()&#10;    }&#10;&#10;    private fun computeGridForRound() {&#10;        val step = (round - 1) / 5&#10;        cols = 4 + step&#10;        rows = 7 + step&#10;        if (cols &lt; 3) cols = 3&#10;        if (rows &lt; 5) rows = 5&#10;    }&#10;&#10;    private fun resizeStacks(newCols: Int) {&#10;        if (stacks.size == newCols) { stacks.forEach { it.clear() }; return }&#10;        stacks = MutableList(newCols) { mutableListOf() }&#10;    }&#10;&#10;    private fun recalcMetrics(contentW: Int, contentH: Int) {&#10;        val tentativeCell = min(contentW / cols.toFloat(), contentH / rows.toFloat())&#10;        labelPaint.textSize = tentativeCell * 0.5f&#10;        labelArea = labelPaint.textSize * 1.6f&#10;        cellSize = min(contentW / cols.toFloat(), (contentH - labelArea) / rows.toFloat())&#10;        val gridW = cellSize * cols&#10;        val gridH = cellSize * rows&#10;        gridLeft = paddingLeft + (contentW - gridW) / 2f&#10;        gridTop = paddingTop + (contentH - (gridH + labelArea)) / 2f&#10;        textPaint.textSize = cellSize * 0.55f&#10;        labelPaint.textSize = cellSize * 0.5f&#10;    }&#10;&#10;    private fun recalcMetricsFromView() {&#10;        val contentW = width - paddingLeft - paddingRight&#10;        val contentH = height - paddingTop - paddingBottom&#10;        if (contentW &gt; 0 &amp;&amp; contentH &gt; 0) recalcMetrics(contentW, contentH)&#10;    }&#10;&#10;    private fun startRound() {&#10;        // Определяем тип сортировки для текущего раунда&#10;        currentSortType = getSortTypeForRound(round)&#10;&#10;        computeGridForRound()&#10;        resizeStacks(cols)&#10;        recalcMetricsFromView()&#10;        moves = 0; notifyMoves()&#10;        val targetCount = maxOf(1, cols - 1)&#10;        targets = IntArray(targetCount)&#10;        val pool = (0..9).shuffled(Random(System.currentTimeMillis()))&#10;        for (i in 0 until targetCount) targets[i] = pool[i]&#10;        val perColumn = (rows - 1).coerceAtLeast(1)&#10;        val bricks = mutableListOf&lt;Int&gt;()&#10;        for (i in 0 until targetCount) repeat(perColumn) { bricks.add(targets[i]) }&#10;        bricks.shuffle(Random(System.currentTimeMillis()))&#10;        var idx = 0&#10;        for (c in 0 until targetCount) {&#10;            val col = stacks[c]&#10;            col.clear(); repeat(perColumn) { col.add(bricks[idx++]) }&#10;        }&#10;        stacks[targetCount].clear()&#10;        onRoundChanged?.invoke(round, targets.copyOf())&#10;        invalidate()&#10;    }&#10;&#10;    private fun notifyMoves() { onMovesChanged?.invoke(moves) }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        recalcMetrics(w - paddingLeft - paddingRight, h - paddingTop - paddingBottom)&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        val bufferColIdx = cols - 1&#10;        val bl = gridLeft + bufferColIdx * cellSize&#10;        val bt = gridTop&#10;        val br = bl + cellSize&#10;        val bb = gridTop + rows * cellSize&#10;        overlayPaint.shader = LinearGradient(&#10;            bl, bt, br, bb,&#10;            Color.argb(28, 0, 200, 83),&#10;            Color.argb(12, 0, 200, 83),&#10;            Shader.TileMode.CLAMP&#10;        )&#10;        canvas.drawRect(bl, bt, br, bb, overlayPaint)&#10;        overlayPaint.shader = null&#10;&#10;        // Рисуем сетку&#10;        for (r in 0 until rows) {&#10;            for (c in 0 until cols) {&#10;                val l = gridLeft + c * cellSize&#10;                val t = gridTop + r * cellSize&#10;                canvas.drawRect(l, t, l + cellSize, t + cellSize, cellBgPaint)&#10;                canvas.drawRect(l, t, l + cellSize, t + cellSize, gridPaint)&#10;            }&#10;        }&#10;&#10;        // Рисуем блоки&#10;        for (c in 0 until cols) {&#10;            val stack = stacks[c]&#10;            for (i in stack.indices) {&#10;                if (dragging &amp;&amp; c == dragFromCol &amp;&amp; i == stack.lastIndex) continue&#10;                val digit = stack[i]&#10;                val r = rows - 1 - i&#10;                drawBlock(canvas, c, r, digit)&#10;            }&#10;        }&#10;&#10;        // Рисуем перетаскиваемый блок&#10;        if (dragging &amp;&amp; dragDigit &gt;= 0) drawFloatingBlock(canvas, dragX, dragY, dragDigit)&#10;&#10;        // Подсветка места для размещения&#10;        if (dragging &amp;&amp; hoverCol &gt;= 0 &amp;&amp; hoverRow &gt;= 0 &amp;&amp; hoverValid) {&#10;            val l = gridLeft + hoverCol * cellSize&#10;            val t = gridTop + hoverRow * cellSize&#10;            overlayPaint.color = Color.argb(80, 56, 142, 60)&#10;            canvas.drawRect(l, t, l + cellSize, t + cellSize, overlayPaint)&#10;        }&#10;&#10;        // Анимация отклонения&#10;        if (rejectCol in 0 until cols) {&#10;            val elapsed = SystemClock.uptimeMillis() - rejectAnimStart&#10;            val p = (elapsed.toFloat() / rejectAnimDuration).coerceIn(0f, 1f)&#10;            if (p &lt; 1f) {&#10;                val alpha = ((1f - p) * 100).toInt().coerceIn(0, 100)&#10;                val l = gridLeft + rejectCol * cellSize&#10;                val t = gridTop&#10;                overlayPaint.color = Color.argb(alpha, 244, 67, 54)&#10;                canvas.drawRect(l, t, l + cellSize, t + cellSize, overlayPaint)&#10;                val shake = (sin(p * Math.PI * 4).toFloat() * cellSize * 0.02f)&#10;                canvas.drawRect(l + shake, t, l + cellSize + shake, t + cellSize, gridPaint)&#10;                postInvalidateOnAnimation()&#10;            } else { rejectCol = -1 }&#10;        }&#10;&#10;        // Анимация принятия&#10;        if (acceptAnimActive) {&#10;            val elapsed = SystemClock.uptimeMillis() - acceptAnimStart&#10;            val p = (elapsed.toFloat() / acceptAnimDuration).coerceIn(0f, 1f)&#10;            if (p &lt; 1f) {&#10;                val l = gridLeft + bufferColIdx * cellSize&#10;                val t = gridTop&#10;                val sweepH = cellSize * p&#10;                overlayPaint.shader = LinearGradient(&#10;                    l, t, l, t + sweepH,&#10;                    Color.argb(120, 76, 175, 80), Color.TRANSPARENT, Shader.TileMode.CLAMP&#10;                )&#10;                canvas.drawRect(l, t, l + cellSize, t + sweepH, overlayPaint)&#10;                overlayPaint.shader = null&#10;                postInvalidateOnAnimation()&#10;            } else { acceptAnimActive = false }&#10;        }&#10;&#10;        // Рисуем метки целей внизу&#10;        drawTargetLabels(canvas)&#10;    }&#10;&#10;    private fun drawBlock(canvas: Canvas, col: Int, row: Int, digit: Int) {&#10;        val cx = gridLeft + col * cellSize + cellSize / 2f&#10;        val cy = gridTop + row * cellSize + cellSize / 2f&#10;        val size = cellSize * 0.9f&#10;        val half = size / 2f&#10;        val left = cx - half&#10;        val top = cy - half&#10;        val right = cx + half&#10;        val bottom = cy + half&#10;        val round = cellSize * 0.18f&#10;&#10;        // Выбираем цвет в зависимости от типа сортировки&#10;        val color = when (currentSortType) {&#10;            SortType.NUMBERS -&gt; digitColors[digit]&#10;            SortType.COLORS -&gt; sortColors[digit]&#10;            SortType.EMOJIS -&gt; digitColors[digit] // Для смайликов используем базовые цвета&#10;        }&#10;&#10;        shadowPaint.color = color&#10;        canvas.drawRoundRect(left + 3f, top + 3f, right + 3f, bottom + 3f, round, round, shadowPaint)&#10;        blockPaint.shader = LinearGradient(&#10;            left, top, right, bottom,&#10;            lighten(color, 0.25f), darken(color, 0.15f), Shader.TileMode.CLAMP&#10;        )&#10;        canvas.drawRoundRect(left, top, right, bottom, round, round, blockPaint)&#10;&#10;        // Выбираем содержимое блока в зависимости от типа сортировки&#10;        when (currentSortType) {&#10;            SortType.NUMBERS -&gt; {&#10;                textPaint.color = if (isColorDark(color)) Color.WHITE else Color.parseColor(&quot;#212121&quot;)&#10;                val fm = textPaint.fontMetrics&#10;                val ty = cy - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(digit.toString(), cx, ty, textPaint)&#10;            }&#10;            SortType.COLORS -&gt; {&#10;                // Для цветов показываем только цветной блок без текста&#10;            }&#10;            SortType.EMOJIS -&gt; {&#10;                textPaint.color = Color.parseColor(&quot;#212121&quot;)&#10;                val originalSize = textPaint.textSize&#10;                textPaint.textSize = cellSize * 0.6f // Увеличиваем размер для смайликов&#10;                val fm = textPaint.fontMetrics&#10;                val ty = cy - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(emojiList[digit], cx, ty, textPaint)&#10;                textPaint.textSize = originalSize // Возвращаем обычный размер&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawFloatingBlock(canvas: Canvas, x: Float, y: Float, digit: Int) {&#10;        val size = cellSize * 0.9f&#10;        val half = size / 2f&#10;        val left = x - half&#10;        val top = y - half&#10;        val right = x + half&#10;        val bottom = y + half&#10;        val round = cellSize * 0.18f&#10;&#10;        // Выбираем цвет в зависимости от типа сортировки&#10;        val color = when (currentSortType) {&#10;            SortType.NUMBERS -&gt; digitColors[digit]&#10;            SortType.COLORS -&gt; sortColors[digit]&#10;            SortType.EMOJIS -&gt; digitColors[digit] // Для смайликов используем базовые цвета&#10;        }&#10;&#10;        shadowPaint.color = color&#10;        canvas.drawRoundRect(left + 3f, top + 3f, right + 3f, bottom + 3f, round, round, shadowPaint)&#10;        blockPaint.shader = LinearGradient(&#10;            left, top, right, bottom,&#10;            lighten(color, 0.25f), darken(color, 0.15f), Shader.TileMode.CLAMP&#10;        )&#10;        canvas.drawRoundRect(left, top, right, bottom, round, round, blockPaint)&#10;&#10;        // Выбираем содержимое блока в зависимости от типа сортировки&#10;        when (currentSortType) {&#10;            SortType.NUMBERS -&gt; {&#10;                textPaint.color = if (isColorDark(color)) Color.WHITE else Color.parseColor(&quot;#212121&quot;)&#10;                val fm = textPaint.fontMetrics&#10;                val ty = y - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(digit.toString(), x, ty, textPaint)&#10;            }&#10;            SortType.COLORS -&gt; {&#10;                // Для цветов показываем только цветной блок без текста&#10;            }&#10;            SortType.EMOJIS -&gt; {&#10;                textPaint.color = Color.parseColor(&quot;#212121&quot;)&#10;                val originalSize = textPaint.textSize&#10;                textPaint.textSize = cellSize * 0.6f // Увеличиваем размер для смайликов&#10;                val fm = textPaint.fontMetrics&#10;                val ty = y - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(emojiList[digit], x, ty, textPaint)&#10;                textPaint.textSize = originalSize // Возвращаем обычный размер&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawTargetLabels(canvas: Canvas) {&#10;        val baseY = gridTop + rows * cellSize + labelArea * 0.65f&#10;        val fm = labelPaint.fontMetrics&#10;        val baseline = baseY - (fm.ascent + fm.descent) / 2f&#10;&#10;        for (c in targets.indices) {&#10;            val cx = gridLeft + c * cellSize + cellSize / 2f&#10;&#10;            // Отображаем метки в зависимости от типа сортировки&#10;            when (currentSortType) {&#10;                SortType.NUMBERS -&gt; {&#10;                    canvas.drawText(targets[c].toString(), cx, baseline, labelPaint)&#10;                }&#10;                SortType.COLORS -&gt; {&#10;                    // Для цветов рисуем маленький цветной квадратик&#10;                    val color = sortColors[targets[c]]&#10;                    val size = labelPaint.textSize * 0.8f&#10;                    val half = size / 2f&#10;                    val rect = RectF(cx - half, baseY - half, cx + half, baseY + half)&#10;                    val paint = Paint().apply {&#10;                        this.color = color&#10;                        isAntiAlias = true&#10;                    }&#10;                    canvas.drawRoundRect(rect, 4f, 4f, paint)&#10;                }&#10;                SortType.EMOJIS -&gt; {&#10;                    val originalSize = labelPaint.textSize&#10;                    labelPaint.textSize = labelPaint.textSize * 1.2f // Увеличиваем размер для смайликов&#10;                    canvas.drawText(emojiList[targets[c]], cx, baseline, labelPaint)&#10;                    labelPaint.textSize = originalSize // Возвращаем обычный размер&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performClick(): Boolean { super.performClick(); return true }&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        when (event.actionMasked) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                val col = colAt(event.x, event.y) ?: return false&#10;                if (stacks[col].isEmpty()) return false&#10;                val touchedRow = rowAt(event.y) ?: return false&#10;                val topRowInCol = rows - 1 - stacks[col].lastIndex&#10;                if (touchedRow != topRowInCol) return false&#10;                dragFromCol = col&#10;                dragDigit = stacks[col].last()&#10;                dragging = true&#10;                dragX = event.x; dragY = event.y&#10;                hoverCol = -1; hoverRow = -1; hoverValid = false&#10;                parent?.requestDisallowInterceptTouchEvent(true)&#10;                invalidate(); return true&#10;            }&#10;            MotionEvent.ACTION_MOVE -&gt; {&#10;                if (!dragging) return false&#10;                dragX = event.x; dragY = event.y&#10;                val col = colAt(event.x, event.y)&#10;                val row = rowAt(event.y)&#10;                hoverCol = -1; hoverRow = -1; hoverValid = false&#10;                if (col != null &amp;&amp; row != null) {&#10;                    val bufferColIdx = cols - 1&#10;                    val cap = if (col == bufferColIdx) rows else (rows - 1).coerceAtLeast(1)&#10;                    val size = stacks[col].size&#10;                    if (size &lt; cap) {&#10;                        val allowedRow = rows - 1 - size&#10;                        if (row == allowedRow) { hoverCol = col; hoverRow = row; hoverValid = true }&#10;                    }&#10;                }&#10;                invalidate(); return true&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                if (!dragging) { performClick(); return false }&#10;                val targetCol = colAt(event.x, event.y)&#10;                var placed = false&#10;                if (targetCol != null) {&#10;                    val bufferColIdx = cols - 1&#10;                    val cap = if (targetCol == bufferColIdx) rows else (rows - 1).coerceAtLeast(1)&#10;                    if (stacks[targetCol].size &lt; cap) {&#10;                        val from = dragFromCol&#10;                        if (from &gt;= 0 &amp;&amp; stacks[from].isNotEmpty() &amp;&amp; stacks[from].last() == dragDigit) {&#10;                            stacks[from].removeAt(stacks[from].lastIndex)&#10;                            stacks[targetCol].add(dragDigit)&#10;                            moves++; notifyMoves(); placed = true&#10;                            if (targetCol == bufferColIdx) {&#10;                                acceptAnimActive = true; acceptAnimStart = SystemClock.uptimeMillis(); postInvalidateOnAnimation()&#10;                            }&#10;                            checkRoundComplete()&#10;                        }&#10;                    } else {&#10;                        performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)&#10;                        if (tone == null) tone = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 80)&#10;                        tone?.startTone(ToneGenerator.TONE_PROP_BEEP, 120)&#10;                        rejectCol = targetCol; rejectAnimStart = SystemClock.uptimeMillis(); postInvalidateOnAnimation()&#10;                    }&#10;                }&#10;                dragging = false&#10;                dragFromCol = -1; dragDigit = -1; hoverCol = -1; hoverRow = -1; hoverValid = false&#10;                invalidate()&#10;                if (!placed) performClick(); return placed&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;&#10;    override fun onDetachedFromWindow() { tone?.release(); tone = null; super.onDetachedFromWindow() }&#10;&#10;    private fun checkRoundComplete() {&#10;        val perColumn = (rows - 1).coerceAtLeast(1)&#10;        for (c in targets.indices) {&#10;            val st = stacks[c]&#10;            if (st.size != perColumn) return&#10;            val need = targets[c]&#10;            if (st.any { it != need }) return&#10;        }&#10;        if (stacks[cols - 1].isNotEmpty()) return&#10;        onRoundCompleted?.invoke(round, moves)&#10;        // Автоматический переход отключён – решает активити (кнопка &quot;далее&quot;)&#10;    }&#10;        // Переход на следующий уровень теперь инициируется извне (через кнопку &quot;далее&quot;)&#10;    private fun colAt(x: Float, y: Float): Int? {&#10;        val withinX = x &gt;= gridLeft &amp;&amp; x &lt; gridLeft + cols * cellSize&#10;        val withinY = y &gt;= gridTop &amp;&amp; y &lt; gridTop + rows * cellSize&#10;        if (!withinX || !withinY) return null&#10;        val col = floor((x - gridLeft) / cellSize).toInt()&#10;        return col.coerceIn(0, cols - 1)&#10;    }&#10;&#10;    private fun rowAt(y: Float): Int? {&#10;        val withinY = y &gt;= gridTop &amp;&amp; y &lt; gridTop + rows * cellSize&#10;        if (!withinY) return null&#10;        val row = floor((y - gridTop) / cellSize).toInt()&#10;        return row.coerceIn(0, rows - 1)&#10;    }&#10;&#10;    private fun lighten(color: Int, amount: Float): Int {&#10;        val a = Color.alpha(color)&#10;        var r = Color.red(color)&#10;        var g = Color.green(color)&#10;        var b = Color.blue(color)&#10;        r = (r + (255 - r) * amount).toInt()&#10;        g = (g + (255 - g) * amount).toInt()&#10;        b = (b + (255 - b) * amount).toInt()&#10;        return Color.argb(a, r, g, b)&#10;    }&#10;&#10;    private fun darken(color: Int, amount: Float): Int {&#10;        val a = Color.alpha(color)&#10;        var r = Color.red(color)&#10;        var g = Color.green(color)&#10;        var b = Color.blue(color)&#10;        r = (r * (1f - amount)).toInt()&#10;        g = (g * (1f - amount)).toInt()&#10;        b = (b * (1f - amount)).toInt()&#10;        return Color.argb(a, r, g, b)&#10;    }&#10;&#10;    private fun isColorDark(color: Int): Boolean {&#10;        val darkness = 1 - (0.299 * Color.red(color) + 0.587 * Color.green(color) + 0.114 * Color.blue(color)) / 255&#10;        return darkness &gt;= 0.5&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.cubesorter&#10;&#10;import android.content.Context&#10;import android.graphics.*&#10;import android.media.AudioManager&#10;import android.media.ToneGenerator&#10;import android.os.SystemClock&#10;import android.util.AttributeSet&#10;import android.view.HapticFeedbackConstants&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import kotlin.math.floor&#10;import kotlin.math.min&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;enum class SortType {&#10;    NUMBERS,   // Сортировка чисел 0-9&#10;    COLORS,    // Сортировка цветов&#10;    EMOJIS     // Сортировка смайликов&#10;}&#10;&#10;class SorterGameView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;    companion object { const val MAX_LEVEL = 40 }&#10;&#10;    var onMovesChanged: ((moves: Int) -&gt; Unit)? = null&#10;    var onRoundChanged: ((round: Int, targets: IntArray) -&gt; Unit)? = null&#10;    var onRoundCompleted: ((round: Int, moves: Int) -&gt; Unit)? = null&#10;    // Новый колбэк при завершении всех уровней&#10;    var onAllCompleted: (() -&gt; Unit)? = null&#10;&#10;    private var cols = 4&#10;    private var rows = 7&#10;&#10;    private var cellSize = 0f&#10;    private var gridLeft = 0f&#10;    private var gridTop = 0f&#10;    private var labelArea = 0f&#10;&#10;    private var stacks: MutableList&lt;MutableList&lt;Int&gt;&gt; = MutableList(cols) { mutableListOf() }&#10;&#10;    private var moves = 0&#10;    private var round = 1&#10;    private var targets: IntArray = IntArray(maxOf(1, cols - 1)) { it }&#10;    // Свойство для получения текущего уровня (используется в активности)&#10;    val currentRound: Int get() = round&#10;&#10;    // Текущий тип сортировки&#10;    private var currentSortType: SortType = SortType.NUMBERS&#10;&#10;    private var dragging = false&#10;    private var dragFromCol = -1&#10;    private var dragDigit = -1&#10;    private var dragX = 0f&#10;    private var dragY = 0f&#10;&#10;    private var hoverCol: Int = -1&#10;    private var hoverRow: Int = -1&#10;    private var hoverValid: Boolean = false&#10;&#10;    private var rejectCol: Int = -1&#10;    private var rejectAnimStart: Long = 0L&#10;    private val rejectAnimDuration = 250L&#10;&#10;    private var acceptAnimActive: Boolean = false&#10;    private var acceptAnimStart: Long = 0L&#10;    private val acceptAnimDuration = 350L&#10;&#10;    private var tone: ToneGenerator? = null&#10;&#10;    private val overlayPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val gridPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        style = Paint.Style.STROKE&#10;        color = Color.parseColor(&quot;#22000000&quot;)&#10;        strokeWidth = 2f * resources.displayMetrics.density&#10;    }&#10;    private val cellBgPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        style = Paint.Style.FILL&#10;        color = Color.parseColor(&quot;#10FFFFFF&quot;)&#10;    }&#10;    private val blockPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val shadowPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        maskFilter = BlurMaskFilter(6f * resources.displayMetrics.density, BlurMaskFilter.Blur.NORMAL)&#10;    }&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        textAlign = Paint.Align.CENTER&#10;        typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;    }&#10;    private val labelPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        textAlign = Paint.Align.CENTER&#10;        typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;        color = Color.parseColor(&quot;#263238&quot;)&#10;    }&#10;&#10;    // Цвета для чисел&#10;    private val digitColors = intArrayOf(&#10;        Color.parseColor(&quot;#FF7043&quot;), // 0 - оранжевый&#10;        Color.parseColor(&quot;#42A5F5&quot;), // 1 - голубой&#10;        Color.parseColor(&quot;#66BB6A&quot;), // 2 - зеленый&#10;        Color.parseColor(&quot;#FFA726&quot;), // 3 - желтый&#10;        Color.parseColor(&quot;#AB47BC&quot;), // 4 - фиолетовый&#10;        Color.parseColor(&quot;#26C6DA&quot;), // 5 - бирюзовый&#10;        Color.parseColor(&quot;#EC407A&quot;), // 6 - розовый&#10;        Color.parseColor(&quot;#7E57C2&quot;), // 7 - сиреневый&#10;        Color.parseColor(&quot;#8D6E63&quot;), // 8 - коричневый&#10;        Color.parseColor(&quot;#FFCA28&quot;)  // 9 - золотой&#10;    )&#10;&#10;    // Цвета для сортировки по цветам&#10;    private val sortColors = intArrayOf(&#10;        Color.parseColor(&quot;#F44336&quot;), // 0 - красный&#10;        Color.parseColor(&quot;#FF9800&quot;), // 1 - оранжевый&#10;        Color.parseColor(&quot;#FFEB3B&quot;), // 2 - желтый&#10;        Color.parseColor(&quot;#4CAF50&quot;), // 3 - зеленый&#10;        Color.parseColor(&quot;#2196F3&quot;), // 4 - синий&#10;        Color.parseColor(&quot;#9C27B0&quot;), // 5 - фиолетовый&#10;        Color.parseColor(&quot;#E91E63&quot;), // 6 - розовый&#10;        Color.parseColor(&quot;#795548&quot;), // 7 - коричневый&#10;        Color.parseColor(&quot;#607D8B&quot;), // 8 - серый&#10;        Color.parseColor(&quot;#000000&quot;)  // 9 - черный&#10;    )&#10;&#10;    // Смайлики для сортировки&#10;    private val emojiList = arrayOf(&#10;        &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;&#10;    )&#10;&#10;    init { isClickable = true; resetAll() }&#10;&#10;    fun resetAll() { moves = 0; round = 1; startRound(); notifyMoves() }&#10;    fun nextRound() {&#10;        // Если текущий раунд меньше максимального – идем дальше, иначе уведомляем о полном завершении&#10;        if (round &lt; MAX_LEVEL) {&#10;            round += 1&#10;            startRound()&#10;        } else {&#10;            onAllCompleted?.invoke()&#10;        }&#10;    }&#10;&#10;    // Определяем тип сортировки для текущего раунда&#10;    private fun getSortTypeForRound(round: Int): SortType {&#10;        // Теперь выбор случайный на каждый раунд&#10;        val types = SortType.values()&#10;        return types[Random.nextInt(types.size)]&#10;    }&#10;&#10;    // Переход на указанный уровень (для режима администратора)&#10;    fun jumpToLevel(level: Int) {&#10;        val target = level.coerceIn(1, MAX_LEVEL)&#10;        round = target&#10;        startRound()&#10;    }&#10;&#10;    private fun computeGridForRound() {&#10;        val step = (round - 1) / 5&#10;        cols = 4 + step&#10;        rows = 7 + step&#10;        if (cols &lt; 3) cols = 3&#10;        if (rows &lt; 5) rows = 5&#10;    }&#10;&#10;    private fun resizeStacks(newCols: Int) {&#10;        if (stacks.size == newCols) { stacks.forEach { it.clear() }; return }&#10;        stacks = MutableList(newCols) { mutableListOf() }&#10;    }&#10;&#10;    private fun recalcMetrics(contentW: Int, contentH: Int) {&#10;        val tentativeCell = min(contentW / cols.toFloat(), contentH / rows.toFloat())&#10;        labelPaint.textSize = tentativeCell * 0.5f&#10;        labelArea = labelPaint.textSize * 1.6f&#10;        cellSize = min(contentW / cols.toFloat(), (contentH - labelArea) / rows.toFloat())&#10;        val gridW = cellSize * cols&#10;        val gridH = cellSize * rows&#10;        gridLeft = paddingLeft + (contentW - gridW) / 2f&#10;        gridTop = paddingTop + (contentH - (gridH + labelArea)) / 2f&#10;        textPaint.textSize = cellSize * 0.55f&#10;        labelPaint.textSize = cellSize * 0.5f&#10;    }&#10;&#10;    private fun recalcMetricsFromView() {&#10;        val contentW = width - paddingLeft - paddingRight&#10;        val contentH = height - paddingTop - paddingBottom&#10;        if (contentW &gt; 0 &amp;&amp; contentH &gt; 0) recalcMetrics(contentW, contentH)&#10;    }&#10;&#10;    private fun startRound() {&#10;        // Определяем тип сортировки для текущего раунда&#10;        currentSortType = getSortTypeForRound(round)&#10;&#10;        computeGridForRound()&#10;        resizeStacks(cols)&#10;        recalcMetricsFromView()&#10;        moves = 0; notifyMoves()&#10;        val targetCount = maxOf(1, cols - 1)&#10;        targets = IntArray(targetCount)&#10;        val pool = (0..9).shuffled(Random(System.currentTimeMillis()))&#10;        for (i in 0 until targetCount) targets[i] = pool[i]&#10;        val perColumn = (rows - 1).coerceAtLeast(1)&#10;        val bricks = mutableListOf&lt;Int&gt;()&#10;        for (i in 0 until targetCount) repeat(perColumn) { bricks.add(targets[i]) }&#10;        bricks.shuffle(Random(System.currentTimeMillis()))&#10;        var idx = 0&#10;        for (c in 0 until targetCount) {&#10;            val col = stacks[c]&#10;            col.clear(); repeat(perColumn) { col.add(bricks[idx++]) }&#10;        }&#10;        stacks[targetCount].clear()&#10;        onRoundChanged?.invoke(round, targets.copyOf())&#10;        invalidate()&#10;    }&#10;&#10;    private fun notifyMoves() { onMovesChanged?.invoke(moves) }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        recalcMetrics(w - paddingLeft - paddingRight, h - paddingTop - paddingBottom)&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        val bufferColIdx = cols - 1&#10;        val bl = gridLeft + bufferColIdx * cellSize&#10;        val bt = gridTop&#10;        val br = bl + cellSize&#10;        val bb = gridTop + rows * cellSize&#10;        overlayPaint.shader = LinearGradient(&#10;            bl, bt, br, bb,&#10;            Color.argb(28, 0, 200, 83),&#10;            Color.argb(12, 0, 200, 83),&#10;            Shader.TileMode.CLAMP&#10;        )&#10;        canvas.drawRect(bl, bt, br, bb, overlayPaint)&#10;        overlayPaint.shader = null&#10;&#10;        // Рисуем сетку&#10;        for (r in 0 until rows) {&#10;            for (c in 0 until cols) {&#10;                val l = gridLeft + c * cellSize&#10;                val t = gridTop + r * cellSize&#10;                canvas.drawRect(l, t, l + cellSize, t + cellSize, cellBgPaint)&#10;                canvas.drawRect(l, t, l + cellSize, t + cellSize, gridPaint)&#10;            }&#10;        }&#10;&#10;        // Рисуем блоки&#10;        for (c in 0 until cols) {&#10;            val stack = stacks[c]&#10;            for (i in stack.indices) {&#10;                if (dragging &amp;&amp; c == dragFromCol &amp;&amp; i == stack.lastIndex) continue&#10;                val digit = stack[i]&#10;                val r = rows - 1 - i&#10;                drawBlock(canvas, c, r, digit)&#10;            }&#10;        }&#10;&#10;        // Рисуем перетаскиваемый блок&#10;        if (dragging &amp;&amp; dragDigit &gt;= 0) drawFloatingBlock(canvas, dragX, dragY, dragDigit)&#10;&#10;        // Подсветка места для размещения&#10;        if (dragging &amp;&amp; hoverCol &gt;= 0 &amp;&amp; hoverRow &gt;= 0 &amp;&amp; hoverValid) {&#10;            val l = gridLeft + hoverCol * cellSize&#10;            val t = gridTop + hoverRow * cellSize&#10;            overlayPaint.color = Color.argb(80, 56, 142, 60)&#10;            canvas.drawRect(l, t, l + cellSize, t + cellSize, overlayPaint)&#10;        }&#10;&#10;        // Анимация отклонения&#10;        if (rejectCol in 0 until cols) {&#10;            val elapsed = SystemClock.uptimeMillis() - rejectAnimStart&#10;            val p = (elapsed.toFloat() / rejectAnimDuration).coerceIn(0f, 1f)&#10;            if (p &lt; 1f) {&#10;                val alpha = ((1f - p) * 100).toInt().coerceIn(0, 100)&#10;                val l = gridLeft + rejectCol * cellSize&#10;                val t = gridTop&#10;                overlayPaint.color = Color.argb(alpha, 244, 67, 54)&#10;                canvas.drawRect(l, t, l + cellSize, t + cellSize, overlayPaint)&#10;                val shake = (sin(p * Math.PI * 4).toFloat() * cellSize * 0.02f)&#10;                canvas.drawRect(l + shake, t, l + cellSize + shake, t + cellSize, gridPaint)&#10;                postInvalidateOnAnimation()&#10;            } else { rejectCol = -1 }&#10;        }&#10;&#10;        // Анимация принятия&#10;        if (acceptAnimActive) {&#10;            val elapsed = SystemClock.uptimeMillis() - acceptAnimStart&#10;            val p = (elapsed.toFloat() / acceptAnimDuration).coerceIn(0f, 1f)&#10;            if (p &lt; 1f) {&#10;                val l = gridLeft + bufferColIdx * cellSize&#10;                val t = gridTop&#10;                val sweepH = cellSize * p&#10;                overlayPaint.shader = LinearGradient(&#10;                    l, t, l, t + sweepH,&#10;                    Color.argb(120, 76, 175, 80), Color.TRANSPARENT, Shader.TileMode.CLAMP&#10;                )&#10;                canvas.drawRect(l, t, l + cellSize, t + sweepH, overlayPaint)&#10;                overlayPaint.shader = null&#10;                postInvalidateOnAnimation()&#10;            } else { acceptAnimActive = false }&#10;        }&#10;&#10;        // Рисуем метки целей внизу&#10;        drawTargetLabels(canvas)&#10;    }&#10;&#10;    private fun drawBlock(canvas: Canvas, col: Int, row: Int, digit: Int) {&#10;        val cx = gridLeft + col * cellSize + cellSize / 2f&#10;        val cy = gridTop + row * cellSize + cellSize / 2f&#10;        val size = cellSize * 0.9f&#10;        val half = size / 2f&#10;        val left = cx - half&#10;        val top = cy - half&#10;        val right = cx + half&#10;        val bottom = cy + half&#10;        val round = cellSize * 0.18f&#10;&#10;        // Выбираем цвет в зависимости от типа сортировки&#10;        val color = when (currentSortType) {&#10;            SortType.NUMBERS -&gt; digitColors[digit]&#10;            SortType.COLORS -&gt; sortColors[digit]&#10;            SortType.EMOJIS -&gt; digitColors[digit] // Для смайликов используем базовые цвета&#10;        }&#10;&#10;        shadowPaint.color = color&#10;        canvas.drawRoundRect(left + 3f, top + 3f, right + 3f, bottom + 3f, round, round, shadowPaint)&#10;        blockPaint.shader = LinearGradient(&#10;            left, top, right, bottom,&#10;            lighten(color, 0.25f), darken(color, 0.15f), Shader.TileMode.CLAMP&#10;        )&#10;        canvas.drawRoundRect(left, top, right, bottom, round, round, blockPaint)&#10;&#10;        // Выбираем содержимое блока в зависимости от типа сортировки&#10;        when (currentSortType) {&#10;            SortType.NUMBERS -&gt; {&#10;                textPaint.color = if (isColorDark(color)) Color.WHITE else Color.parseColor(&quot;#212121&quot;)&#10;                val fm = textPaint.fontMetrics&#10;                val ty = cy - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(digit.toString(), cx, ty, textPaint)&#10;            }&#10;            SortType.COLORS -&gt; {&#10;                // Для цветов показываем только цветной блок без текста&#10;            }&#10;            SortType.EMOJIS -&gt; {&#10;                textPaint.color = Color.parseColor(&quot;#212121&quot;)&#10;                val originalSize = textPaint.textSize&#10;                textPaint.textSize = cellSize * 0.6f // Увеличиваем размер для смайликов&#10;                val fm = textPaint.fontMetrics&#10;                val ty = cy - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(emojiList[digit], cx, ty, textPaint)&#10;                textPaint.textSize = originalSize // Возвращаем обычный размер&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawFloatingBlock(canvas: Canvas, x: Float, y: Float, digit: Int) {&#10;        val size = cellSize * 0.9f&#10;        val half = size / 2f&#10;        val left = x - half&#10;        val top = y - half&#10;        val right = x + half&#10;        val bottom = y + half&#10;        val round = cellSize * 0.18f&#10;&#10;        // Выбираем цвет в зависимости от типа сортировки&#10;        val color = when (currentSortType) {&#10;            SortType.NUMBERS -&gt; digitColors[digit]&#10;            SortType.COLORS -&gt; sortColors[digit]&#10;            SortType.EMOJIS -&gt; digitColors[digit] // Для смайликов используем базовые цвета&#10;        }&#10;&#10;        shadowPaint.color = color&#10;        canvas.drawRoundRect(left + 3f, top + 3f, right + 3f, bottom + 3f, round, round, shadowPaint)&#10;        blockPaint.shader = LinearGradient(&#10;            left, top, right, bottom,&#10;            lighten(color, 0.25f), darken(color, 0.15f), Shader.TileMode.CLAMP&#10;        )&#10;        canvas.drawRoundRect(left, top, right, bottom, round, round, blockPaint)&#10;&#10;        // Выбираем содержимое блока в зависимости от типа сортировки&#10;        when (currentSortType) {&#10;            SortType.NUMBERS -&gt; {&#10;                textPaint.color = if (isColorDark(color)) Color.WHITE else Color.parseColor(&quot;#212121&quot;)&#10;                val fm = textPaint.fontMetrics&#10;                val ty = y - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(digit.toString(), x, ty, textPaint)&#10;            }&#10;            SortType.COLORS -&gt; {&#10;                // Для цветов показываем только цветной блок без текста&#10;            }&#10;            SortType.EMOJIS -&gt; {&#10;                textPaint.color = Color.parseColor(&quot;#212121&quot;)&#10;                val originalSize = textPaint.textSize&#10;                textPaint.textSize = cellSize * 0.6f // Увеличиваем размер для смайликов&#10;                val fm = textPaint.fontMetrics&#10;                val ty = y - (fm.ascent + fm.descent) / 2f&#10;                canvas.drawText(emojiList[digit], x, ty, textPaint)&#10;                textPaint.textSize = originalSize // Возвращаем обычный размер&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawTargetLabels(canvas: Canvas) {&#10;        val baseY = gridTop + rows * cellSize + labelArea * 0.65f&#10;        val fm = labelPaint.fontMetrics&#10;        val baseline = baseY - (fm.ascent + fm.descent) / 2f&#10;&#10;        for (c in targets.indices) {&#10;            val cx = gridLeft + c * cellSize + cellSize / 2f&#10;&#10;            // Отображаем метки в зависимости от типа сортировки&#10;            when (currentSortType) {&#10;                SortType.NUMBERS -&gt; {&#10;                    canvas.drawText(targets[c].toString(), cx, baseline, labelPaint)&#10;                }&#10;                SortType.COLORS -&gt; {&#10;                    // Для цветов рисуем маленький цветной квадратик&#10;                    val color = sortColors[targets[c]]&#10;                    val size = labelPaint.textSize * 0.8f&#10;                    val half = size / 2f&#10;                    val rect = RectF(cx - half, baseY - half, cx + half, baseY + half)&#10;                    val paint = Paint().apply {&#10;                        this.color = color&#10;                        isAntiAlias = true&#10;                    }&#10;                    canvas.drawRoundRect(rect, 4f, 4f, paint)&#10;                }&#10;                SortType.EMOJIS -&gt; {&#10;                    val originalSize = labelPaint.textSize&#10;                    labelPaint.textSize = labelPaint.textSize * 1.2f // Увеличиваем размер для смайликов&#10;                    canvas.drawText(emojiList[targets[c]], cx, baseline, labelPaint)&#10;                    labelPaint.textSize = originalSize // Возвращаем обычный размер&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performClick(): Boolean { super.performClick(); return true }&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        when (event.actionMasked) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                val col = colAt(event.x, event.y) ?: return false&#10;                if (stacks[col].isEmpty()) return false&#10;                val touchedRow = rowAt(event.y) ?: return false&#10;                val topRowInCol = rows - 1 - stacks[col].lastIndex&#10;                if (touchedRow != topRowInCol) return false&#10;                dragFromCol = col&#10;                dragDigit = stacks[col].last()&#10;                dragging = true&#10;                dragX = event.x; dragY = event.y&#10;                hoverCol = -1; hoverRow = -1; hoverValid = false&#10;                parent?.requestDisallowInterceptTouchEvent(true)&#10;                invalidate(); return true&#10;            }&#10;            MotionEvent.ACTION_MOVE -&gt; {&#10;                if (!dragging) return false&#10;                dragX = event.x; dragY = event.y&#10;                val col = colAt(event.x, event.y)&#10;                val row = rowAt(event.y)&#10;                hoverCol = -1; hoverRow = -1; hoverValid = false&#10;                if (col != null &amp;&amp; row != null) {&#10;                    val bufferColIdx = cols - 1&#10;                    val cap = if (col == bufferColIdx) rows else (rows - 1).coerceAtLeast(1)&#10;                    val size = stacks[col].size&#10;                    if (size &lt; cap) {&#10;                        val allowedRow = rows - 1 - size&#10;                        if (row == allowedRow) { hoverCol = col; hoverRow = row; hoverValid = true }&#10;                    }&#10;                }&#10;                invalidate(); return true&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                if (!dragging) { performClick(); return false }&#10;                val targetCol = colAt(event.x, event.y)&#10;                var placed = false&#10;                if (targetCol != null) {&#10;                    val bufferColIdx = cols - 1&#10;                    val cap = if (targetCol == bufferColIdx) rows else (rows - 1).coerceAtLeast(1)&#10;                    if (stacks[targetCol].size &lt; cap) {&#10;                        val from = dragFromCol&#10;                        if (from &gt;= 0 &amp;&amp; stacks[from].isNotEmpty() &amp;&amp; stacks[from].last() == dragDigit) {&#10;                            stacks[from].removeAt(stacks[from].lastIndex)&#10;                            stacks[targetCol].add(dragDigit)&#10;                            moves++; notifyMoves(); placed = true&#10;                            if (targetCol == bufferColIdx) {&#10;                                acceptAnimActive = true; acceptAnimStart = SystemClock.uptimeMillis(); postInvalidateOnAnimation()&#10;                            }&#10;                            checkRoundComplete()&#10;                        }&#10;                    } else {&#10;                        performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)&#10;                        if (tone == null) tone = ToneGenerator(AudioManager.STREAM_NOTIFICATION, 80)&#10;                        tone?.startTone(ToneGenerator.TONE_PROP_BEEP, 120)&#10;                        rejectCol = targetCol; rejectAnimStart = SystemClock.uptimeMillis(); postInvalidateOnAnimation()&#10;                    }&#10;                }&#10;                dragging = false&#10;                dragFromCol = -1; dragDigit = -1; hoverCol = -1; hoverRow = -1; hoverValid = false&#10;                invalidate()&#10;                if (!placed) performClick(); return placed&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;&#10;    override fun onDetachedFromWindow() { tone?.release(); tone = null; super.onDetachedFromWindow() }&#10;&#10;    private fun checkRoundComplete() {&#10;        val perColumn = (rows - 1).coerceAtLeast(1)&#10;        for (c in targets.indices) {&#10;            val st = stacks[c]&#10;            if (st.size != perColumn) return&#10;            val need = targets[c]&#10;            if (st.any { it != need }) return&#10;        }&#10;        if (stacks[cols - 1].isNotEmpty()) return&#10;        onRoundCompleted?.invoke(round, moves)&#10;        // Автоматический переход отключён – решает активити (кнопка &quot;далее&quot;)&#10;    }&#10;        // Переход на следующий уровень теперь инициируется извне (через кнопку &quot;далее&quot;)&#10;    private fun colAt(x: Float, y: Float): Int? {&#10;        val withinX = x &gt;= gridLeft &amp;&amp; x &lt; gridLeft + cols * cellSize&#10;        val withinY = y &gt;= gridTop &amp;&amp; y &lt; gridTop + rows * cellSize&#10;        if (!withinX || !withinY) return null&#10;        val col = floor((x - gridLeft) / cellSize).toInt()&#10;        return col.coerceIn(0, cols - 1)&#10;    }&#10;&#10;    private fun rowAt(y: Float): Int? {&#10;        val withinY = y &gt;= gridTop &amp;&amp; y &lt; gridTop + rows * cellSize&#10;        if (!withinY) return null&#10;        val row = floor((y - gridTop) / cellSize).toInt()&#10;        return row.coerceIn(0, rows - 1)&#10;    }&#10;&#10;    private fun lighten(color: Int, amount: Float): Int {&#10;        val a = Color.alpha(color)&#10;        var r = Color.red(color)&#10;        var g = Color.green(color)&#10;        var b = Color.blue(color)&#10;        r = (r + (255 - r) * amount).toInt()&#10;        g = (g + (255 - g) * amount).toInt()&#10;        b = (b + (255 - b) * amount).toInt()&#10;        return Color.argb(a, r, g, b)&#10;    }&#10;&#10;    private fun darken(color: Int, amount: Float): Int {&#10;        val a = Color.alpha(color)&#10;        var r = Color.red(color)&#10;        var g = Color.green(color)&#10;        var b = Color.blue(color)&#10;        r = (r * (1f - amount)).toInt()&#10;        g = (g * (1f - amount)).toInt()&#10;        b = (b * (1f - amount)).toInt()&#10;        return Color.argb(a, r, g, b)&#10;    }&#10;&#10;    private fun isColorDark(color: Int): Boolean {&#10;        val darkness = 1 - (0.299 * Color.red(color) + 0.587 * Color.green(color) + 0.114 * Color.blue(color)) / 255&#10;        return darkness &gt;= 0.5&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>